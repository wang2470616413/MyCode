# 2019.6.12
### lca(求两点最近公共祖先)
#### &emsp;&emsp;1.Tarjan(离线求LCA)
##### &emsp;&emsp;&emsp;&emsp;&emsp;大致思路就是跑一边dfs,在跑的过程标记已经跑过点的。例如我要查询x~y的lca,那么如果跑完y的时候，x也已经跑完了。那就说明在跑完的图中,x,y至少有一个公共祖先的。根据dfs序的特性(<font color = red>dfs总是先把深度最大的点先跑完，而在x,y中所有的公共祖先中，最近的公共祖先一定是深度最大的</font>)。
#### &emsp;&emsp;2.倍增算法(离线求LCA)
##### &emsp;&emsp;&emsp;&emsp;&emsp;倍增就是在一棵树上以2的次幂往上跳，比如某个节点向上跳len个节点。那么我们假定的len的二进制是1110101,那么我们就知道了我们就知道了我们需要向上跳 2^0 * 1 + 2^1 * 0 + 2^2 * 1 + 2^3 * 0 + 2^4 * 1 + 2^5 * 1 + 2^6 * 1。这一点对应代码中 `71~77`行。那么`82~89`行是从上向下跳，因为在最近公共祖先之上的每一个简单节点都是公共祖先。所以我们发现如果`fa[ta][i] != fa[tb][i]`说明`fa[ta][i]，fa[tb][i]`所代表的节点一定在最近公共祖先的下面。当然做这一切的前提是你需要进行`37~61`的bfs初始化
